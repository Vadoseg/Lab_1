# Ответы

## Вопрос 1.6

### Поясните следующую строку кода:
   
    localparam COUNTER_WIDTH = int'($ceil($clog2(COUNTER_PERIOD +1)));

Данная строка кода обозначает создание локального параметра.

1.1 localparam - отличается от parameter тем, что параметр - это глобальная константа, а локальный параметр - локальная константа. Также локальный параметр может быть изменён на протяжении работы кода, в отличие от parameter.

1.2 В данной формуле мы рассчитываем длительность сигнала счётчика, в нашем случае это повлияет на длительность сигнала светодиода.
Период счётчика + 1, суммирование используется для добавления дополнительного битового значения - это требуется для корректного отображения значения COUNTER_PERIOD.

1.3 $clog2() - Функция логарифма по основанию 2.

1.4 $ceil - Округление в большую сторону.

1.5 int'() - Преобразование в тип integer.

## Вопрос 1.8

### Как вы думаете, почему в приборах используют именно мигающие индикаторы, а не постоянно светящиеся?

В приборах используют мигающие светодиоды, чтобы легче было отследить неисправности. Человеческому глазу легче заметить, среди всех статичных элементов механизма, мигающий объект.

## Вопрос 2.1

### В чем отличия синтезируемого и несинтезируемого подмножеств языков описания?

1.1 Синтезируемое подмножество включает элементы языка, которые могут быть преобразованы в прошивку и загружены на устройство без изменений исходного кода. 

1.2 Несинтезируемое подмножество предназначено для моделирования работы устройства вне самого устройства и позволяет имитировать задержки срабатывания транзисторов и отдельных вентилей

Таким образом, синтезируемое подмножество используется для создания реальных устройств, а несинтезируемое — для проверки работоспособности и отладки программного обеспечения перед его реализацией на реальном устройстве.

## Вопрос 3.1 и 3.2 

### Из каких элементов состоит синтезированная схема? Какие еще элементы могут составлять схему?

1.1 Регистры данных, счётчики и т.п.

1.2 Буферы

1.3 Логические элементы(AND, OR, XOR и т.п.)

1.4. Провода

1.5 LUT'ы

1.6 Модули

1.7 Входы\Выходы

## Вопрос 3.3

### Как изменится схема, если отключить сигнал i_rst от входа микросхемы?

Пропадёт вход для сигнала i_rst на схеме и пропадёт буфер (i_rst IBUF). Если же полностью убрать i_rst, то исчезнет возможность перезапуска счётчика вручную при помощи кнопки.

## Вопрос 3.4

### Почему в симуляторе (в blink_led_tb) можно использовать тип real, а в описании модуля (blink_led) этот тип можно использовать только для вычисления констант?

Потому что тип real, как и time является несинтезируемым и его нужно преобразовать в другой тип данных. А тестбенч не синтезируется.

## Вопрос 3.5

### Можно ли разделить значение счетчика counter_value на какое-нибудь число? Будет ли такое описание синтезировано? Будет ли синтезировано умножение counter_value на число?

1.1 Счётчик можно разделить на число. Схема будет синтезирована, но её размеры увеличиваются больше, чем в 10 раз.(Если без деления, то размер схемы включает в себя 52 ячейки, когда с делением 628 ячеек).

1.2 Умножение на число синтезируется, никаких значительных проблем со схемой нет.

## Вопрос 4.1

### Как располагаются элементы дизайна на кристалле микросхемы?

1.1 Определение параметров и портов модулей.

1.2 Соединение портов модулей через соединения (wires) или через сигналы (nets).

1.3 Соединение логических элементов на кристалле(Неуверен)

## Вопрос 4.2

### На что влияет параметр тактовой частоты в файле ограничений timings.xdc? Что будет, если указать период ТЧ 1 нс?

1.1 Данный параметр создает clock с заданным периодом и именем, и присваивает его порту, который мы указываем.

1.2 Если указать период 1 наносекунду, то с таким периодом будет поступать сигнал с clock'а, который мы указываем.

## Вопрос 4.3

### Что определяет параметр IOSTANDARD в pinouts.xdc?

Параметр IOSTANDARD в pinouts.xdc определяет стандарт ввода-вывода для портов на целевом устройстве. Он указывает программу, которая будет использоваться для настройки входных, выходных и двунаправленных портов.

## Вопрос 5.1

### Что произойдет с платой и прошивкой, если выключить и включить питание? Как можно объяснить результат?

Плата перезагрузится, если программа хранится в энергозависимой ячейке памяти ОЗУ, то при рестарте она сбросится, а программа сотрётся. Если же программа хранится в энергозависимой flash-памяти, то при подобном рестарте, программа сохранится. В открытых источниках упоминается, что на платах марки Xilinx программа хранится в ячейках статической памяти ОЗУ, следовательно при подобном перезапуске программа сотрётся.

## Вопрос 5.2

### Что такое JTAG? Зачем он необходим?

JTAG - это интерфейс ставший промашленным стандартом. Практически все цифровые микросхемы им оснащаются. Он используется для тестировки и отладки.

## Вопрос 6.1

### Отличия always_ff и always_comb?

1.1 Always_ff используется для описания синхронной последовательностной логики, например триггеров. Always_ff срабатывает на изменение сигнала, указанного в списке чувствительности.

1.2 Always_comb используется для моделирования комбинационной логики.

## Вопрос 6.2

### В чем разница между разными видами присвоения: а = с и a <= c?

1.1 Блокирующее присваивание (=) выполняет операцию присваивания и блокирует выполнение последующих операторов до тех пор, пока операция не завершится.

1.2 Неблокирующее присваивание (<=) выполняет операцию присваивания без блокировки и позволяет другим операторам выполняться параллельно.

## Вопрос 6.3

### Поясните, за что отвечает фрагмент кода:
    а) reg [COUNTER_WIDTH -1 : 0] counter_value = '0;

    б) always_ff @(posedge i_clk) begin

    в) assign o_led = {0:(~i_rstn | led_on), default:(~i_rstn | ~led_on)} ;

    г) localparam COUNTER_WIDTH = int($ceil($clog2(COUNTER_PERIOD +1)));

    д) always #(T_CLK/2) i_clk = ~i_clk;

    е) 	initial begin
        i_rstn = 1'b1;
        #10e3 i_rstn = 1'b0;
        #(20*T_CLK) i_rstn = 1'b1;
        end

## Фрагмент кода А:

    reg [COUNTER_WIDTH -1 : 0] counter_value = '0;

Создается счётчик со значением бит = COUNTER_WIDTH. Тип данных счётчика reg - значит, что переменная может хранить информацию, пока не поступит новая.

## Фрагмент кода Б:

    always_ff @(posedge i_clk) begin

Создается процесс-триггер, который отслеживает передний фронт i_clk. И будет срабатывать в зависимости от сигнала клока.

## Фрагмент кода В:

    assign o_led = {0:(~i_rstn | led_on), default:(~i_rstn | ~led_on)} ;

Непрерывное присвоение o_led значение led_on в случае, если ~i_rstn равен 0, при любом другом значении o_led присваивается значение ~led_on.

## Фрагмент кода Г:

    localparam COUNTER_WIDTH = int($ceil($clog2(COUNTER_PERIOD +1)));

Отвечал в 1.6.

## Фрагмент кода Д:

    always #(T_CLK/2) i_clk = ~i_clk;

Подобная запись используется при написании тестбенчей. На протяжении всей симуляции будет инвертироваться сигнал i_clk с периодом (T_CLK/2).

## Фрагмент кода E:

    initial begin
    i_rstn = 1'b1;
    #10e3 i_rstn = 1'b0;
    #(20*T_CLK) i_rstn = 1'b1;
    end

Подобная запись также используется при написании тестбенчей. Значит, что каждая строка прописанная в блоке initial, будет выполнена 1 раз. Либо сразу, либо с указанным периодом.

## Вопрос 6.4

### Отличия двух деклараций сигналов:
    reg [COUNTER_WIDTH -1 : 0] counter_value = '0;
    wire [COUNTER_WIDTH -1 : 0] counter_value = '0;

В данном случае:

1.1 Первая запись может стать счётчиком и хранить в себе информацию, пока не получит новое.

1.2 Вторая запись не может быть счётчиком и не может хранить в себе информацию, т.к. тип данных wire не поддерживает эту возможность.